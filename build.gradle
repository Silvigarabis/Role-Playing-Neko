plugins {
    id 'com.github.johnrengelman.shadow' version '8.1.1' apply false
}

println project_name + " " + version

import java.util.Properties;
import java.io.*;
import java.nio.charset.StandardCharsets;

ext {
    enabled_platforms = getProperty("platforms").tokenize(',').collect { it.trim() }
    enabled_platform_projects = enabled_platforms.collect { project(":platform_" + it) }

    enabled_platforms.each { platform_name ->
        def platform_project = project(":platform_" + platform_name)
        platform_project.ext.platform_type = platform_name
    }

    Properties infoProperties = new Properties();
    infoProperties.load(new InputStreamReader(new FileInputStream(file("info.properties")), StandardCharsets.UTF_8));

    group = properties["maven_group"]
    archives_base_name = properties["archives_base_name"]
    version = properties["version"]

    description = infoProperties.get("description") as String
    author = infoProperties.get("author") as String
    license = infoProperties.get("license") as String
    website = infoProperties.get("website") as String
    issues = infoProperties.get("issues") as String
    authors = infoProperties.get("authors") as String
    contributors = infoProperties.get("contributors") as String
    
    println description
}

println "platform(s) that enabled: " + enabled_platforms

allprojects {
    tasks.withType(JavaCompile) {
        options.compilerArgs += ['-Xlint:deprecation', '-Xlint:rawtypes', '-Xlint:deprecation', '-Xlint:unchecked']
    }
}

subprojects {
    if (project in enabled_platform_projects){
        version = version + "+" + project.platform_type
    } else {
        version = version + "+" + project.name
    }

    apply plugin: "java"

    dependencies {
        compileOnly 'org.jetbrains:annotations:24.0.0'
    }

    base {
        archivesName = archives_base_name
    }
}

subprojects {
    if (!(project in enabled_platform_projects)){
        return;
    }

    apply plugin: "com.github.johnrengelman.shadow"

    dependencies {
        implementation(project(":core"))
        shadow(project(":core"))
    }

    shadowJar {
        configurations = [project.configurations.shadow]

        archiveClassifier = ""
    }

    build {
        dependsOn "shadowJar"
    }
}

/*
task build(type: Copy) {

    dependsOn subprojects.collect { it.tasks.named("build") }

    def jarTasks = [ "jar", "remapJar", "sourcesJar", "remapSourcesJar", "shadowJar"]

    subprojects.each { project -> jarTasks.each { taskName -> 
        def task = project.tasks.findByPath(taskName);
        if (task){
            def out = task.outputs.files
            println "will copy from " + out
            from(out)
        }
    }}

    into "$rootDir/out"
}
*/

import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

task build {
    dependsOn subprojects.collect { it.tasks.named("build") }

    doLast {
        def jarTasks = [ "jar", "remapJar", "sourcesJar", "remapSourcesJar", "shadowJar" ]
    
        def outDir = file("build/libs/");
        outDir.mkdirs();
    
        subprojects.each { project -> jarTasks.each { taskName -> 
            def task = project.tasks.findByPath(taskName);
    
            if (task){
                def out = task.outputs.files.singleFile
                //println "(build/libs/) will copy from task " + task + ":" + out.path
                Files.copy(Paths.get(out.path), Paths.get(outDir.path, out.name), StandardCopyOption.REPLACE_EXISTING);
            }
        }}
        
    }

    doLast {
        def jarTasks = [ "shadowJar", "jar" ]
    
        def outDir = file("out/");
        outDir.mkdirs();
    
        enabled_platform_projects.each { project ->
            for (def taskName : jarTasks){
                def task = project.tasks.findByPath(taskName);
                if (task){
                    def out = task.outputs.files.singleFile
                    //println "(out/) will copy from task " + task + ":" + out.path
                    Files.copy(Paths.get(out.path), Paths.get(outDir.path, out.name), StandardCopyOption.REPLACE_EXISTING);
                    return;
                }
            }
        }
        
    }
}

task clean(type: Delete){
    delete "build/"
    delete "out/"
}
