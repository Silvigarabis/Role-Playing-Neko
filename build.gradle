plugins {
    id 'com.github.johnrengelman.shadow' version '8.1.1' apply false
}

println "RolePlayingNeko " + version

ext {
    core_project = project(":core")
    common_project = project(":common")

    enabled_platforms = getProperty("platforms").tokenize(',').collect { it.trim() }
    enabled_platform_projects = enabled_platforms.collect { project(":" + it) }

    ctlibmod_version = properties["ctlibmod_version"]

}

println "platform(s) that enabled: " + enabled_platforms

allprojects {
    tasks.withType(JavaCompile) {
        options.compilerArgs += ['-Xlint:deprecation']
    }
}

subprojects { project ->
    def isPlatformProject = project in enabled_platform_projects
    def isConfigLoaderProject  = project.name.startsWith("configloader")

    apply plugin: "java"
    if (isPlatformProject){
        apply plugin: "com.github.johnrengelman.shadow"
    }

    repositories {
        mavenCentral()
        maven {
            name = "Modrinth"
            url = "https://api.modrinth.com/maven"
            content {
                includeGroup "maven.modrinth"
            }
        }
    }

    group = properties["maven_group"] as String
    version = properties["version"] as String + "+" + project.name
    description = properties["description"] as String
    archives_base_name = properties["archives_base_name"] as String

    base {
        archivesName = archives_base_name
    }

    configurations {
        shadow
    }

    dependencies {
        implementation 'org.jetbrains:annotations:24.0.0'
        implementation 'maven.modrinth:ctlibmod:${ctlibmod_version}'
        if (isPlatformProject){
            shadow(common_project)
            compileOnly(common_project)
        }
        if (isConfigLoaderProject){
            compileOnly(core_project)
        }
    }

}

enabled_platform_projects.each { project ->
    project.tasks.getByName('shadowJar') {
        configurations = [project.configurations.shadow]

        archiveClassifier = ""
    }

    project.tasks.named('build') {
        dependsOn project.tasks.named('shadowJar')
    }
}

task build(type: Copy) {
    mustRunAfter( subprojects.collect { it.tasks.named('build') } )

    def jarTasks = [ "jar", "remapJar", "sourcesJar", "javadocJar" ]
    jarTasks.each { jarTask ->
        subprojects.each { project ->
            if (project.tasks.findByPath(jarTask)){
                from(project.tasks.getByName(jarTask).outputs.files.singleFile)
            }
        }
    }
    into "$rootDir/out"
}
